* Inputs infrastructure  
* integrate inputs manager & unity input system
to switch between 2 systems using that infrastructure
* `PlayerInputProvider.cs` uses inputsManager (tool created by yassine)
![[ToolINputMan.png]]
* Basically uses api Unity Input System legacy (old)

![[InputManager.png]]

* rn MVC code works with `PlayerInputProviderAuthoring.cs`
* the new infrastucture allows to switch between input systems dynamically (2 diff setups)
* we'll make a layer between MVC and inputProviders


## **Phase 1: UnityLegacyInputProvider** 
### **What You're Building:** 
1. **Component Struct** (`UnityLegacyInputProvider.cs`)
- Stores the actual input VALUES (steering: 0.5, throttle: 0.8, etc.) 
- Implements `IInputProvider` interface 
- Must be `[BurstCompile]` compatible (no managed types!) 
2. **Configuration Companion** (`UnityLegacyInputConfiguration.cs`) 
- Stores the axis NAME strings ("Horizontal", "Vertical", etc.) 
- A class, not a struct (because strings aren't blittable) 
3. **Authoring Component** (`UnityLegacyInputProviderAuthoring.cs`) 
- MonoBehaviour with public fields visible in Inspector 
- Lets designers configure which axes to use 
- Example: `public string steeringAxis = "Horizontal";` 
4. **Baker** (`UnityLegacyInputProviderBaker.cs`) 
- Converts authoring → ECS components during baking 
- Adds BOTH the provider struct AND the configuration companion 
5. **System** (`UnityLegacyInputProviderSystem.cs`) 
- Runs every frame in `InitializationSystemGroup` 
- Reads `Input.GetAxis()` using axis names from config 
- Writes values into the provider struct
### **Data Flow:**
```
Inspector Fields (Authoring)
    ↓ (Baker runs at edit-time)
UnityLegacyInputConfiguration (strings) + UnityLegacyInputProvider (struct)
    ↓ (System runs at runtime)
Input.GetAxis("Horizontal") → provider.Steering = -0.7
    ↓ (Vehicle systems read the provider)
Vehicle steers left!
```
### **2. The Managed Companion Pattern**

Here's the tricky part: **ECS components can only contain blittable data** (simple value types like `float`, `int`, `bool`).

But we need to store:

- **Strings** (for axis names like "Horizontal") ❌ Not blittable!
- **InputAction references** (for new Input System) ❌ Not blittable!

**Solution**: We use a **managed companion component** (a class that implements `IComponentData`) to store these non-blittable references alongside our struct.
## **Quick Reference: File Purposes**

|File|"What does it do?"|
|---|---|
|**Component.cs**|"I store the input values"|
|**Configuration.cs**|"I store the axis names"|
|**Authoring.cs**|"I'm the Inspector UI"|
|**Baker.cs**|"I convert authoring → ECS at bake time"|
|**System.cs**|"I read Unity's Input and update the component every frame"|
