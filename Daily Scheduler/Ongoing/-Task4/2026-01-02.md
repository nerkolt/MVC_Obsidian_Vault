## Architecture Overview

```
[Global Settings] → Picks which plugin is active
         ↓
[Active Plugin] → Reads input from devices
         ↓
[MVC System] → Queries which vehicles need input
         ↓
[Vehicle Entity] → Gets the input values written to it

```

* ***Global Configuration** is like a settings file that says: _"Hey, we're using Xbox controllers today"_ (or keyboard, or whatever).
![[Pasted image 20260102201612.png]]
* ***Plugins** are like different "translators" - one speaks "Xbox controller language", another speaks "keyboard language". Each plugin knows how to read from specific input devices.
![[Pasted image 20260102201634.png]]
* ***MVC Core** is the manager that says: _"Okay, let me check which cars need input, ask the plugin for those values, and give each car what it needs."_
![[Pasted image 20260102201650.png]]
* ***Vehicles** are your race cars that just receive steering/throttle/brake values - they don't care where those values came from.

## Core Components
### 1. **PluginInputProvider** (The Translator Interface)
This is an **abstract class** - think of it as a contract that says:

> "Any plugin that wants to provide input MUST be able to answer these questions:
> 
> - What's the steering value for player X?
> - What's the throttle value for player X?
> - What's the brake value for player X?"

```csharp
// Simplified version
public abstract class PluginInputProvider
{
    // Every plugin MUST implement these
    public abstract float GetSteering(int playerId);
    public abstract float GetThrottle(int playerId);
    public abstract float GetBrake(int playerId);
    
    // Bonus methods for advanced features
    public virtual bool GetShiftUp(int playerId) { /* ... */ }
}
```

Notice the `playerId` parameter? That's how we handle split-screen! Player 0 might be on keyboard, Player 1 on gamepad #1, Player 2 on gamepad #2, etc.

### 2. **PlayerIdentifier** (The Car's ID Badge)
This is a **component** on each vehicle that says: _"I belong to Player 2"_

```csharp
public struct PlayerIdentifier : IComponentData
{
    public int Id;  // 0, 1, 2, 3 for players 1, 2, 3, 4
}
```

When you set up a car in the editor, you add `PlayerIdentifierAuthoring` and set the player ID. This gets baked into the `PlayerIdentifier` component.

### 3. **VehicleInputSettings** (The Global Switch)

This is a **ScriptableSingleton** (basically a global settings object) that stores ONE number:

```csharp
public class VehicleInputSettings : ScriptableSingleton<VehicleInputSettings>
{
    public int DefaultPluginHash;  // Which plugin is active?
}
```

In the editor, you pick your plugin (like "InputSystemProvider"), and this saves its hash. At runtime, the system looks at this hash to know which plugin to use.

### 4. **PluginInputReaderSystem** (The Delivery Service)

![[Pasted image 20260102221741.png]]
This is the **ECS System** that runs every frame and does the actual work:

```csharp
// Pseudocode of what it does each frame
foreach (var vehicle in AllVehicles)
{
    // Step 1: Get the vehicle's player ID
    int playerId = vehicle.PlayerIdentifier.Id;
    
    // Step 2: Ask the active plugin for this player's input
    float steering = activePlugin.GetSteering(playerId);
    float throttle = activePlugin.GetThrottle(playerId);
    float brake = activePlugin.GetBrake(playerId);
    
    // Step 3: Write these values to the vehicle's input component
    vehicle.Powertrain.Inputs.Steering = steering;
    vehicle.Powertrain.Inputs.Throttle = throttle;
    vehicle.Powertrain.Inputs.Brake = brake;
}
```

* This **same system** runs in both the ECS World (for SubScene entities) and the HybridMono World (for GameObjects). That's why it extends `SystemBase`.

---
#### The Data Flow (Following the Second Flowchart)

Let's trace what happens **every single frame**:

###### Frame N starts...

**1. Input Device Level**
```
Player 2 presses right on gamepad → Raw input: analog stick at 0.75
```

**2. Plugin Level**
```
PluginInputReaderSystem: "Hey InputSystemProvider, what's the steering for Player 2?"
InputSystemProvider: "Let me check Player 2's gamepad... it's 0.75"
```

**3. System Level**
```
PluginInputReaderSystem: "Got it. Writing 0.75 to Car B's Powertrain.Inputs.Steering"
```

**4. Vehicle Level**
```
PowertrainSystem: "Reading inputs... steering is 0.75, applying to physics..."
Car B turns right!
```

This happens **60 times per second** for all inputs on all vehicles!

---

#### Split-Screen Magic (Third Flowchart Explained)

This is where it gets cool. Let's say you have 3 cars in split-screen:
```
Scene Setup:
- Car A: PlayerIdentifier.Id = 0 (Player 1 on keyboard)
- Car B: PlayerIdentifier.Id = 1 (Player 2 on Gamepad 1)
- Car C: PlayerIdentifier.Id = 2 (Player 3 on Gamepad 2)

Active Plugin: InputSystemProvider.asset
```

Inside `InputSystemProvider`, you've configured:
- "When playerId=0, read from Keyboard bindings"
- "When playerId=1, read from Gamepad 1 bindings"
- "When playerId=2, read from Gamepad 2 bindings"

**Each frame:**
```
System queries Car A → playerId = 0 → Plugin reads Keyboard → Car A gets keyboard input
System queries Car B → playerId = 1 → Plugin reads Gamepad 1 → Car B gets gamepad 1 input
System queries Car C → playerId = 2 → Plugin reads Gamepad 2 → Car C gets gamepad 2 input